---
title: 计算机操作系统
date: 2023-08-31 15:25:53
---

# 操作系统的概念



**操作系统**（Operating System， OS）是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调

度计算机的工作和资源的分配；以提供给用户和其他软件方便的接口和环境；它是计算机系统中最基本

的系统软件。

# 计算机系统的层次结构



![img](https://cdn.nlark.com/yuque/0/2021/png/21471868/1632450834584-4011107d-5bd0-4974-9ce2-44b7660114dc.png)

# 操作系统的功能



**作为系统资源的管理者，提供的功能。**



（1）处理机管理



（2）存储器管理



（3）文件管理



（4）设备管理



**向上层提供方便易用的服务**



（1）程序接口（又称为系统调用）



（2）命令接口



联机命令接口



脱机命令接口



（3）GUI界面



**对硬件的扩展**



没有任何软件支持的计算机成为裸机。在裸机上安装的操作系统，可以提供资源管理功能和方便用户的服务功能，将裸机改造成功能更强、使用更方便的机器。通常把覆盖了软件的机器成为扩充机器，又称之为虚拟机



# 操作系统特征



**并发**



并发：指两个或多个事件在同一时间间隔内发生，这些事件宏观上是同时发生的，但微观上是交替发生的。



并行：指两个或多个事件在同一时刻同时发生。



操作系统的并发性指计算机系统中“同时”运行着多个程序，这些程序宏观上看是同时运行着的，而微观

上看是交替运行的。



单核CPU同一时刻只能执行一个程序，各个程序只能并发地执行。



多核CPU同一时刻可以同时执行多个程序，多个程序可以并行地执行。



并发性指计算机系统中同时存在着多个运行着的程序。



**共享**



共享即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。



两种资源共享方式



（1）互斥共享



同一时间段内摄像头只能分配给其中一个进程。



（2）同时共享



两个进程都在访问硬盘资源，从中读取数据。





共享性是指系统中的资源可供内存中多个并发执行的进程共同使用。



**虚拟**



虚拟是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体（前者）是实际存在的，而逻辑上

对应物（后者）是用户感受到的。



（1）空分复用技术



如虚拟存储器



（2）时分复用技术



如虚拟处理器



**异步**



异步是指，在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，

而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。



# 操作系统的发展和分类



（1）手工操作阶段



主要缺点：用户独占全机、人机速度矛盾导致资源利用率极低



（2）单道批处理系统



引入脱机输入/输出技术（用外围机+磁带完成），并由**监督程序（**操作系统雏形**）**负责控制作业的输入、输出。



主要缺点：内存中仅能有一道程序运行，只有该程序运行结束之后才能调入下一道程序。CPU有大量的时间是在

空闲等待I/O完成。资源利用率依然很低。



（3）多道批处理系统



操作系统正式诞生



主要缺点：用户响应时间长，没有人机交互功能



（4）分时操作系统



计算机以时间片为单位轮流为各个用户/作业服务，各个用户可通过终端与计算机进行交互。用户请求可以被即时响应，解决了人机交互问题。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在。



主要缺点：不能优先处理一些紧急任务。操作系统对各个用户/作业都是完全公平的，循环地为每个用户/作业服务一个时间片，不区分任务的紧急性。



（5）实时操作系统



能够优先响应一些紧急任务，某些紧急任务不需时间片排队。在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且要在严格的时限内处理完事件。实时操作系统的主要特点是及时性和可靠性。



**硬实时操作系统**



必须在规定的时间内完成处理



**软实时操作系统**



偶尔违反时间规定



（6）网络操作系统



伴随着计算机网络的发展而诞生的，能把网络中各个计算机有机地结合起来，实现数据传送等功能，实现网络中各种资源的共享（如文件共享）和各台计算机之间的通信。



（7）分布式操作系统



主要特点是分布性和并行性。系统中的各台计算机地位相同，任何工作都可以分布在这些计算机上，由它们并行、协同完成这个任务。



（8）个人计算机操作系统



# 操作系统的运行机制和体系结构



“指令”就是处理器（CPU）能识别、执行的最基本命令。



**（1）两种指令**



特权指令



如内存清零



非特权指令



**（2）CPU两种状态**



CPU 有两种状态，“内核态”和“用户态”。



CPU 中有一个寄存器叫程序状态字寄存器（PSW），其中有个二进制位，1表示“内核态”，0表示“用户态”。



处于内核态时，说明此时正在运行的是内核程序，此时可以执行特权指令



处于用户态时，说明此时正在运行的是应用程序，此时只能执行非特权指令



**（3）内核程序和应用程序**



**内核程序**



操作系统的内核程序是系统的管理者，既可以执行特权指令，也可以执行非特权指令，运行在核心态。



**应用程序**



为了保证系统能安全运行，普通应用程序只能执行非特权指令，运行在用户态。



计算机体系结构



![img](https://cdn.nlark.com/yuque/0/2021/png/21471868/1632455082710-755ac474-1d47-4db4-a488-f2620ed7943c.png)

内核是计算机上配置的底层软件，是操作系统最基本、最核心的部分。实现操作系统内核功能的那些程序就是内核程序。



原语是一种特殊的程序。是最接近硬件的部分，这种程序的运行具有原子性。



时钟管理：实现计时功能。



**大内核**



优点：性能高



缺点：代码庞大，结构混乱，难以维护。



**微内核**



优点：结构清晰，维护方便



缺点：需要频繁地在用户态和核心态切换，性能低。



# 中断和异常



**中断**



（1）内中断（异常）



与当前执行的指令有关，中断信号来源于CPU内部



如整数除0



（2）外中断



与当前执行的指令无关，中断信号来源于CPU外部



如时钟中断、IO请求中断



时钟部件每隔一个时间片（如50ms）会给CPU发送一个时钟中断信号。



发生中断意味着操作系统介入开展管理工作，CPU立即进入核心态。



- 当中断发生时，CPU立即进入核心态



- 当中断发生后，当前运行的进程暂停运行，并由操作系统内核对中断进行处理



- 对于不同的中断信号，会进行不同的处理





**用户态和核心态之间的切换**



**“中断”是让操作系统内核夺回CPU使用权的唯一途径。**



用户态切换到内核态：由“中断”引发，触发中断信号意味着操作系统将强行夺回CPU的使用权。



内核态切换到用户态：执行一条特权指令——修改PSW的标志位为“用户态”，这个动作意味着操作系统

将主动让出CPU使用权。

# 系统调用



操作系统作为用户和计算机硬件之间的接口，需要向上提供一些简单易用的服务。主要包括命令接

口和程序接口。其中，程序接口由一组系统调用组成。



应用程序通过系统调用请求操作系统的服务。而系统中的各种共享资源都由操作系统内核统一掌管，因此凡是

与共享资源有关的操作（如存储分配、I/O操作、文件管理等），都必须通过系统调用的方式向操作系统内核提

出服务请求，由操作系统内核代为完成。这样可以保证系统的稳定性和安全性，防止用户进行非法操作。



（1）陷入指令是在用户态执行的，执行陷入指令之后立即引发一个内中断，使CPU进入核心态。



（2）发出系统调用请求是在用户态，而对系统调用的相应处理在核心态下进行。



（3）陷入指令是唯一一个CPU在核心态下无法执行的指令。



**系统调用与库函数的区别**



向上提供库函数。有时会将系统调用封装成库函数，以隐藏系统调用的一些细节，使程序员编程更加方便。



# 进程



进程（Process）：程序的一次执行过程。



程序：是静态的，就是个存放在磁盘里的可执行文件，就是一系列的指令集合



**进程的组成**



- PCB（进程控制块，描述进程的各种信息）
- 程序段
- 数据段



PCB记录了以下内容



（1）进程描述信息



进程标识符PID



用户标识符UID



（2）进程控制和管理信息



进程当前状态（就绪态、阻塞态、运行态）



（3）资源分配信息



（4）处理机信息



各种寄存器的值



PCB是进程存在的唯一标志，当进程被创建时，操作系统为其创建PCB，当进程结束时，会回收其PCB。



程序段、数据段、PCB三部分组成了进程实体。



进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。



**进程的组织**



（1）链接方式



按照进程状态，将PCB分为多个队列，操作系统持有指向各个队列的指针。



![img](https://cdn.nlark.com/yuque/0/2021/png/21471868/1632470187857-5e5514c6-b1e4-4f9a-b0f0-2c4335fb8d8f.png)



（2）索引方式



按照进程状态，建立几张索引表，操作系统持有指向各个索引表的指针。



![img](https://cdn.nlark.com/yuque/0/2021/png/21471868/1632470263830-dbf94783-c476-4265-8358-bf3cb1754fb0.png)

**进程的几种状态**



（1）创建态



在这个阶段操作系统会为进程分配资源、初始化PCB



（2）就绪态



当进程创建完成后，便进入“就绪态”，处于就绪态的进程已经具备运行条件，但由于没有空闲CPU，就暂时不能运行。



（3）运行态



如果一个进程此时在CPU上运行，那么这个进程处于“运行态”。



（4）阻塞态



在进程运行的过程中，可能会请求等待某个事件的发生（如等待某种系统资源的分配）在这个事件发生之前，进程无法继续往下执行，此时操作系统会让这个进程下CPU，并让它进入“阻塞态”



（5）终止态



进程正在从系统中撤销，操作系统会回收进程拥有的资源、撤销PCB







![img](https://cdn.nlark.com/yuque/0/2021/png/21471868/1632475135086-1c46c084-5074-496c-816d-929a00ed3c46.png)



进程PCB中，会有一个变量state 来表示进程的当前状态。如：1表示创建态、2表示就绪态、3表示运行态。



**进程控制**



进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现

进程状态转换等功能。



![img](https://cdn.nlark.com/yuque/0/2021/png/21471868/1632477098768-6355e493-53fd-45b1-8ad2-3b4a7f928cfc.png)

![img](https://cdn.nlark.com/yuque/0/2021/png/21471868/1632477363441-53d8c989-7a3e-4186-a643-54b32ec7b930.png)

进程的切换采用原语实现，采用“关中断指令”和“开中断指令”实现。



原语的执行具有原子性，即执行过程只能一气呵成，期间不允许被中断。



**进程控制相关的原语**



（1）创建原语



- 申请空白PCB



- 为新进程分配所需资源



- 初始化PCB



- 将PCB插入就绪队列



（2）撤销原语



- 找到终止进程PCB



- 若进程正在运行，剥夺CPU，将CPU分配给其他进程



- 终止所有子进程



- 资源回收



- 删除PCB



（3）阻塞原语



- 找到阻塞进程PCB



- 保存当前状态，将PCB更改为阻塞态



- 将PCB插入相应事件的等待队列



（4）唤醒原语



- 从阻塞等待队列中找到PCB



- 将PCB状态更改为就绪态，从等待队列中移除



- 插入就绪队列，等待被CPU调度



阻塞原语唤醒原语必须成对使用



（5）切换原语



- 将运行环境信息存入PCB



- 将PCB移入相应队列当中



- 选择另一个进程运行，更改PCB信息



- 根据PCB信息，恢复运行环境



运行态切换到就绪态



就绪态切换到运行态



**进程通信**



进程通信就是指进程之间的信息交换



进程是分配系统资源的单位（包括内存地址空间），因此各进程拥有的内存地址空间相互独立。为了保证安全，一个进程不能直接访问另一个进程的地址空间。



进程间通信的三种方式



**（1）共享存储**



- 基于数据结构的共享



比如共享空间里只能放一个长度为10的数组。这种共享方式速度慢、限制多，是一种低级通信方式



- 基于存储区的共享



在内存中画出一块共享存储区，数据的形式、存放位置都由进程控制，而不是操作系统。相比之下，这种共享方式速度更快，是一种高级通信方式



两个进程对共享空间的访问必须是**互斥的**



![img](https://cdn.nlark.com/yuque/0/2021/png/21471868/1632480853291-167046c5-3491-44b8-af48-828b37773d85.png)



**（2）管道通信**



![img](https://cdn.nlark.com/yuque/0/2021/png/21471868/1632480910969-7675c972-ef55-40a1-a766-7e7cbdc4f085.png)



管道”是指用于连接读写进程的一个共享文件，又名pipe文件。其实就是在内存中开辟一个大小固定的缓冲区



- 半双工通信



- 全双工通信



（1）管道只能采用半双工通信，某一时间段内只能实现单向的传输。如果要实现双向同时通信，则需要设置两个管道。



（2）各进程要互斥地访问管道。



（3）数据以字符流的形式写入管道，当管道写满时，写进程的write()系统调用将被阻塞，等待读进程将数据取

走。当读进程将数据全部取走后，管道变空，此时读进程的read()系统调用将被阻塞。



（4）如果没写满，就不允许读。如果没读空，就不允许写。



（5）数据一旦被读出，就从管道中被抛弃，这就意味着读进程最多只能有一个，否则可能会有读错数据的情况。



**（3）消息传递**



进程间的数据交换以格式化的消息（Message）为单位。进程通过操作系统提供的“发送消息/接收消息”两个原语进行数据交换。



![img](https://cdn.nlark.com/yuque/0/2021/png/21471868/1632481057001-2aac6b0d-7b91-4904-a963-3552eac58a96.png)



- 直接通信



消息直接挂到对方的缓存消息队列



![img](https://cdn.nlark.com/yuque/0/2021/png/21471868/1632481216679-325b43cf-fdfb-4308-a997-21831d6bda90.png)



- 间接通信



![img](https://cdn.nlark.com/yuque/0/2021/png/21471868/1632481240280-8f6e08b4-2065-40e6-83c8-3e3306447f8d.png)



消息先发送到中间信箱



**进程同步**



进程具有异步性的特征。异步性是指，各并发执行的进程以各自独立的、不可预知的速度向前推进。



来看一个例子

![img](https://cdn.nlark.com/yuque/0/2021/png/21471868/1634387625177-43ca8aa5-94a8-4e3c-b565-1a813fe66dda.png)

读进程和写进程并发地运行，由于并发必然导致异步性，因此“写数据”和“读数据”两个操作执行的先后顺序是不确定的。而实际应用中，又必须按照“写数据 -> 读数据”的顺序来执行的。如何解决这种异步问题，就是“进程同步”所讨论的内容。



**进程互斥**



进程的“并发”需要“共享”的支持。各个并发执行的进程不可避免的需要共享一些系统资源（比如内存，又比如打印机、摄像头这样的I/O设备）



两种资源共享方式



（1）互斥共享



系统中的某些资源，虽然可以提供给多个进程使用，但一个时间段内只允许一个进程访问该资源



（2）同时共享



系统中的某些资源，允许一个时间段内由多个进程“同时”对它们进行访问



我们把一个时间段内只允许一个进程使用的资源称为临界资源。许多物理设备（比如摄像头、打印机）都属于临界资源。此外还有许多变量、数据、内存缓冲区等都属于临界资源。对临界资源的访问，必须互斥地进行。



对临界资源的互斥访问，可以在逻辑上分为如下四个部分



![img](https://cdn.nlark.com/yuque/0/2021/png/21471868/1634387860770-b56a75af-f390-4939-929d-2403e349073f.png)

临界区是进程中访问临界资源的代码段



进入区和退出区是负责实现互斥的代码段



临界区也可称为“临界段”



为了实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循以下原则



（1）空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区



（2）忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待



（3）有限等待。对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）



（4）让权等待。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待



**进程互斥的软件实现方式**



**（1）单标志检查法**



两个进程在访问完临界区后会把使用临界区的权限转交给另一个进程。



**（2）双标志先检查法**



设置一个布尔型数组flag[]，数组中各个元素用来标记各进程想进入临界区的意愿，比如“flag[0] = ture”意味着0 号进程P0 现在想要进入临界区。每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区，如果没有，则把自身对应的标志flag[i] 设为true。



**（3）双标志后检查法**



双标志先检查法的改版。前一个算法的问题是先“检查”后“上锁”，但是这两个操作又无法一气呵成，因此导致了两个进程同时进入临界区的问题。因此，人们又想到先“上锁”后“检查”的方法，来避免上述问题。



**（4）Peterson 算法**



结合双标志法、单标志法的思想。如果双方都争着想进入临界区，那可以让进程尝试“孔融让梨”（谦让）。做一个有礼貌的进程。



**进程互斥的硬件实现方式**



**（1）中断屏蔽**



**（2）TestAndSet指令**



**（3）Swap指令**



# 线程



传统方式

![img](https://cdn.nlark.com/yuque/0/2021/png/21471868/1632628869036-80bdfb36-8d3e-4380-b897-f50a69b0bc55.png)

传统的进程是程序执行流的最小单位。



引入线程机制之后，提高了系统的并发度



![img](https://cdn.nlark.com/yuque/0/2021/png/21471868/1632628960668-053ad801-0966-48c6-b511-bf1c1c95f213.png)

线程是一个基本的CPU执行单元，也是程序执行流的最小单位。引入线程之后，不仅是进程之间可以并发，进程内的各线程之间也可以并发，从而进一步提升了系统的并发度，使得一个进程内也可以并发处理各种任务（如QQ视频、文字聊天、传文件）



进程是资源分配的基本单位，线程是调度的基本单位。



多CPU计算机中，各个线程可占用不同的CPU。



每个线程都有一个线程ID，线程控制块。



同一进程不同线程之间共享进程资源。



线程的实现方式有两种，用户级线程以及内核级线程。



**用户级线程**



早期的操作系统（如：早期Unix）只支持进程，不支持线程。当时的“线程”是由线程库实现的

![img](https://cdn.nlark.com/yuque/0/2021/png/21471868/1632629482110-cba4a610-29ec-4606-9761-ff2fc55d61fd.png)



用户级线程由应用程序通过线程库实现，所有的线程管理工作都由应用程序负责（包括线程切换）



用户级线程中，线程切换可以在用户态下即可完成，无需操作系统干预。



在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在。“用户级线程”就是“从用户视角看能看到的线程”



优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高



缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行。



**内核级线程**



![img](https://cdn.nlark.com/yuque/0/2021/png/21471868/1632631177458-f3ea275c-d090-446e-ba44-836a4757b985.png)

大多数现代操作系统都实现了内核级线程，如Windows、Linux



内核级线程的管理工作由操作系统内核完成。



线程调度、切换等工作都由内核负责，因此内核级线程的切换必然需要在核心态下才能完成。



操作系统会为每个内核级线程建立相应的TCB（Thread Control Block，线程控制块），通过TCB对线程进行管理。“内核级线程”就是“从操作系统内核视角看能看到的线程”



优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。



缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。



**多线程模型**



一对一模型：一个用户级线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程。

![img](https://cdn.nlark.com/yuque/0/2021/png/21471868/1632631464750-8b95358d-56a4-4c55-9a99-6d7f02617524.png)

多对一模型：多个用户级线程映射到一个内核级线程。且一个进程只被分配一个内核级线程。

![img](https://cdn.nlark.com/yuque/0/2021/png/21471868/1632631461004-7b3c2421-30a8-4fae-9a3a-3581fffc5793.png)

多对多模型：n 用户及线程映射到m 个内核级线程（n >= m）。每个用户进程对应m 个内核级线程。



![img](https://cdn.nlark.com/yuque/0/2021/png/21471868/1632631727009-d015110a-d0ee-49c0-a903-7a822019c192.png)

内核级线程才是处理机分配的单位

# 调度



当有一堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定某种规则来决定处理

这些任务的顺序，这就是“调度”。



## 三种调度方式



**高级调度**（作业调度）



按一定的原则从外存的作业后备队列中挑选一个作业调入内存，并创建进程。每个作业只调入一次，调出一次。作业调入时会建立PCB，调出时才撤销PCB。



**中级调度**（内存调度）



内存不够时，可将某些进程的数据调出外存。等内存空闲或者进程需要运行时再重新调入内存。暂时调到外存等待的进程状态为挂起状态。被挂起的进程PCB会被组织成挂起队列



按照某种策略决定将哪个处于挂起状态的进程重新调入内存。一个进程可能会被多次调出、调入内存，因此中级调度发生的频率要比高级调度更高。



**低级调度**（进程调度）



按照某种策略从就绪队列中选取一个进程，将处理机分配给它。进程调度的频率很高，一般几十毫秒一次。



七状态模型



![img](https://cdn.nlark.com/yuque/0/2021/png/21471868/1633078676365-65baaf12-d6f0-4210-899c-7c9b8ac7cb3e.png)

**需要进程调度和切换的情况**



- **当前运行的进程主动放弃处理机**



进程正常终止



运行过程中发生异常而终止



进程主动请求阻塞（如等待I/O）



- **当前运行的进程被动放弃处理机**



分给进程的时间片用完



有更紧急的事需要处理（如I/O中断）



有更高优先级的进程进入就绪队列



**不能进行进程调度与切换的情况**



在处理中断的过程中。中断处理过程复杂，与硬件密切相关，很难做到在中断处理过程中进行进程切换



进程在**操作系统内核程序临界区**中（一段访问系统资源的代码）



临界资源：一个时间段内只允许一个进程使用的资源。各进程需要互斥地访问临界资源。



临界区：访问临界资源的那段代码。



内核程序临界区一般是用来访问某种内核数据结构的，比如进程的就绪队列（由各就绪进程的PCB组成）。



进程在普通临界区中是可以进行调度、切换的。



在原子操作过程中（原语）。原子操作不可中断，要一气呵成（如之前讲过的修改PCB中进程状态标志，并把PCB放到相应队列）



**进程调度的方式**



非剥夺调度方式，又称非抢占方式。



只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。



剥夺调度方式，又称抢占方式。



当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程。



**进程切换**



进程切换是指一个进程让出处理机，由另一个进程占用处理机的过程。



进程切换的过程主要完成了：



（1）对原来运行进程各种数据的保存



（2）对新的进程各种数据的恢复



（如：程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一般保存在进程控制块）



进程切换是有代价的，因此如果过于频繁的进行进程调度、切换，必然会使整个系统的效率降低，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少。



## 调度算法的评价指标



**CPU利用率**



CPU利用率：指CPU “忙碌”的时间占总时间的比例。



![img](https://cdn.nlark.com/yuque/__latex/17787cb2b890f13511ae0df3d24e1c64.svg)

**系统吞吐量**



单位时间内完成作业的数量



![img](https://cdn.nlark.com/yuque/__latex/fe47c69f87e2dbb53545838229ad053c.svg)

**周转时间**



是指从作业被提交给系统开始，到作业完成为止的这段时间间隔。



包括四个部分：作业在外存后备队列上等待作业调度（高级调度）的时间、进程在就绪队列上等待进程调度（低级调度）的时间、进程在CPU上执行的时间、进程等待I/O操作完成的时间。后三项在一个作业的整个处理过程中，可能发生多次。



![img](https://cdn.nlark.com/yuque/__latex/b3ed7991c8aff8afe173924ccac98a72.svg)



**带权周转时间**



![img](https://cdn.nlark.com/yuque/__latex/6e1d4c878a8aa5af257c9b2dffc1149a.svg)



**等待时间**



指进程/作业处于等待处理机状态时间之和



对于进程来说，等待时间就是指进程建立后等待被服务的时间之和，在等待I/O完成的期间其实进程也是在被服务的，所以不计入等待时间。对于作业来说，不仅要考虑建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间。



**响应时间**



指从用户提交请求到首次产生响应所用的时间



## 调度算法



**先来先服务（FCFS）**



按照作业/进程到达的先后顺序进行服务



用于作业/进程调度，属于非抢占式算法。不会导致作业/进程饥饿。



**短作业优先（SJF）**



最短的作业/进程优先得到服务（所谓“最短”，是指要求服务时间最短）



用于作业/进程调度，属于非抢占式算法，可能导致进程饥饿。



**最短剩余时间优先算法（SRTN）**



每当有进程加入就绪队列改变时就需要调度，如果新到达的进程剩余时间比当前运行的进程剩余时

间更短，则由新进程抢占处理机，当前运行进程重新回到就绪队列



抢占式短作业优先算法



**高响应比优先（HRRN）**



在每次调度时先计算各个作业/进程的响应比，选择响应比最高的作业/进程为其服务



![img](https://cdn.nlark.com/yuque/__latex/b90881145a26fc40b56782ad1310ebf5.svg)



非抢占式的算法，只有当前运行的作业/进程主动放弃处理机时，才需要调度，才需要计算响应比。



**时间片轮转（RR）**



按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片（如100ms）。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队。



用于进程调度（只有作业放入内存建立了相应的进程后，才能被分配处理机时间片）



若进程未能在时间片内运行完，将被强行剥夺处理机使用权，因此时间片轮转调度算法属于抢占式的算法。由时钟装置发出时钟中断来通知CPU时间片已到



**优先级调度算法**



每个作业/进程有各自的优先级，调度时选择优先级最高的作业/进程。既可用于作业调度，也可用于进程调度。



有抢占式和非抢占式版本。非抢占式只需在进程主动放弃处理机时进行调度即可，而抢占式还需在就绪队列变化时，检查是否会发生抢占。



根据优先级是否可以动态改变，可将优先级分为静态优先级和动态优先级两种。



静态优先级：创建进程时确定，之后一直不变。



动态优先级：创建进程时有一个初始值，之后会根据情况动态地调整优先级。



进程优先级



（1）系统进程优先级高于用户进程



（2）前台进程优先级高于后台进程



（3）操作系统更偏好I/O型进程（或称I/O繁忙型进程）与I/O型进程相对的是计算型进程（或称CPU繁忙型进程）



如果某进程在就绪队列中等待了很长时间，则可以适当提升其优先级。如果某进程占用处理机运行了很长时间，则可适当降低其优先级。如果发现一个进程频繁地进行I/O操作，则可适当提升其优先级。



**多级反馈队列调度算法**



![img](https://cdn.nlark.com/yuque/0/2021/png/21471868/1634386877919-86b03038-9404-4466-bab5-5463ad6e4d15.png)



设置多级就绪队列，各级队列优先级从高到低，时间片从小到大



新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片。若用完时间片进程还

未结束，则进程进入下一级队列队尾。如果此时已经在最下级的队列，则重新放回最下级

队列队尾。



只有第k级队列为空时，才会为k+1 级队头的进程分配时间片被抢占处理机的进程重新放回原队列队尾。

# 内存

## 什么是内存



程序执行前需要先放到内存中才能被CPU处理——缓和CPU与硬盘之间的速度矛盾



### 地址编址的两种方式



按字编址



如果计算机“按字节编址”，则每个存储单元大小为1字节，即1B



按字节编址



如果字长为16位的计算机“按字编址”，则每个存储单元大小为1个字；每个字的大小为16 个二进制位



### 逻辑地址与物理地址



程序经过编译、链接后生成的指令中指明的是逻辑地址（相对地址），即：相对于进程的起始地址而言的地址



### 程序的运行原理



![img](https://cdn.nlark.com/yuque/0/2021/png/21471868/1636284652091-9ca158df-1cde-4550-9f26-dd7d0cf9b4d9.png)

编译：由编译程序将用户源代码编译成若干个目标模块（编译就是把高级语言翻译为机器语言）



链接：由链接程序将编译后形成的一组目标模块，以及所需库函数链接在一起，形成一个完整的装入模块



装入（装载）：由装入程序将装入模块装入内存运行



### 链接的三种方式



（1）静态链接



在程序运行之前，先将各目标模块及它们所需的库函数连接成一个完整的可执行文件（装入模块），之后不再拆开



（2）装入时动态链接



将各目标模块装入内存时，边装入边链接的链接方式



（3）运行时动态链接



在程序执行中需要该目标模块时，才对它进行链接。其优点是便于修改和更新，便于实现对目标模块的共享



### 指令三种装入方式



（1）绝对装入



在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码。装入程序按照装入模块中的地址，将程序和数据装入内存。



（2）静态重定位



编译、链接后的装入模块的地址都是从0开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址。可根据内存的当前情况，将装入模块装入到内存的适当位置。装入时对地址进行“重定位”，将逻辑地址变换为物理地址（地址变换是在装入时一次完成的）



静态重定位的特点是在一个作业装入内存时，必须分配其要求的全部内存空间，如果没有足够的内存，就不能装入该作业。作业一旦进入内存后，在运行期间就不能再移动，也不能再申请内存空间。



（3）动态重定位



编译、链接后的装入模块的地址都是从0开始的。装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是把地址转换推迟到程序真正要执行时才进行。因此装入内存后所有的地址依然是逻辑地址。这种方式需要一个重定位寄存器的支持。



### 内存管理



（1）操作系统负责内存空间的分配与回收



（2）操作系统需要提供某种技术从逻辑上对内存空间进行扩充



（3）操作系统需要提供地址转换功能，负责程序的逻辑地址与物理地址的转换



（4）操作系统需要提供内存保护功能。保证各进程在各自存储空间内运行，互不干扰



内存保护可采取两种方法



方法一



在CPU中设置一对上、下限寄存器，存放进程的上、下限地址。进程的指令要访问某个地址时，CPU检查是否越界



方法二



采用重定位寄存器（又称基址寄存器）和界地址寄存器（又称限长寄存器）进行越界检查。重定位寄存器中存放的是进程的起始物理地址。界地址寄存器中存放的是进程的最大逻辑地址



### 内存空间



内存空间的扩充有三种方式



（1）覆盖技术



覆盖技术的思想：将程序分为多个段（多个模块）。常用的段常驻内存，不常用的段在需要时调入内存。

内存中分为一个“固定区”和若干个“覆盖区”。需要常驻内存的段放在“固定区”中，调入后就不再

调出（除非运行结束）不常用的段放在“覆盖区”，需要用到时调入内存，用不到时调出内存



（2）交换技术



![img](https://cdn.nlark.com/yuque/0/2021/png/21471868/1636286039464-dc78d548-804d-4379-84bc-9267a6be4ff5.png)

交换（对换）技术的设计思想：内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存（进程在内存与磁盘间动态调度）暂时换出外存等待的进程状态为挂起状态（挂起态，suspend）挂起态又可以进一步细分为就绪挂起、阻塞挂起两种状态



具有对换功能的操作系统中，通常把磁盘空间分为**文件区**和**对换区**两部分。文件区主要用于存放文件，主要追求存储空间的利用率，因此对文件区空间的管理采用离散分配方式；对换区空间只占磁盘空间的小部分，被换出的进程数据就存放在对换区。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理主要追求换入换出速度，因此通常对换区采用连续分配方式，对换区的I/O速度比文件区的更快。



交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停。例如：在发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程；如果缺页率明显下降，就可以暂停换出。



可优先换出阻塞进程；可换出优先级低的进程；为了防止优先级低的进程在被调入内存后很快又被换出，有的系统还会考虑进程在内存的驻留时间（注意：PCB 会常驻内存，不会被换出外存）



（3）虚拟存储技术



**覆盖技术与交换技术的区别**



覆盖技术发生在同一进程/程序中，交换技术是不同进程/作业之间的。



### 内存分配方式



连续分配



（1）单一连续分配



![img](https://cdn.nlark.com/yuque/0/2021/png/21471868/1636286527693-36420a75-5fa8-4d82-84df-24119e125839.png)



在单一连续分配方式中，内存被分为系统区和用户区。系统区通常位于内存的低地址部分，用于存放操作系统

相关数据；用户区用于存放用户进程相关数据。内存中只能有一道用户程序，用户程序独占整个用户区空间



（2）固定分配方式



![img](https://cdn.nlark.com/yuque/0/2021/png/21471868/1636286585750-13242051-02a2-48f8-a245-0a178f232cbc.png)



为了能在内存中装入多道程序，且这些程序之间又不会相互干扰，于是将整个用户空间划分为若干个固定大小的分区，在每个分区中只装入一道作业，这样就形成了最早的、最简单的一种可运行多道程序的内存管理方式。



操作系统需要建立一个数据结构——分区说明表，来实现各个分区的分配与回收。每个表项对应一个分区，通常按分区大小排列。每个表项包括对应分区的大小、起始地址、状态（是否已分配）。



![img](https://cdn.nlark.com/yuque/0/2021/png/21471868/1636286648579-cdbd1e8b-d375-42c0-a41f-412628f0913a.png)



（3）动态分区分配



动态分区分配又称为可变分区分配。这种分配方式不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的。



可采用空闲分区表或空闲分区链记录内存的使用情况



空闲分区表



![img](https://cdn.nlark.com/yuque/0/2021/png/21471868/1636286861210-7a65b82f-fcab-434d-aaa9-49ae033d0f95.png)



空闲分区链



![img](https://cdn.nlark.com/yuque/0/2021/png/21471868/1636286887519-2c2cee60-37f3-466f-997f-0197c5484d49.png)

把一个新作业装入内存时，须按照一定的动态分区分配算法，从空闲分区表（或空闲分区链）中选出一个分区分配给该作业。由于分配算法算法对系统性能有很大的影响。



动态分区分配没有内部碎片，但是有外部碎片。



内部碎片，分配给某进程的内存区域中，如果有些部分没有用上。



外部碎片，是指内存中的某些空闲分区由于太小而难以利用。



非连续分配管理方式
